

#### 01 比较 Counter 对象和 dict 对象

**联系：**

1. 存储唯一键值对。
2. Counter 对象是 dict 的子类，支持大部分 dict 对象的操作。

**区别：**

1. **数据结构：**
   - Counter 对象：用于对可哈希对象的出现次数进行计数，主要用于统计元素的频率。
   - dict 对象：一般的字典，可存储任意可哈希对象的键值对。

2. **提供的方法：**
   - Counter 对象提供了 `most_common()` 等特殊方法，用于获取出现频率最高的元素。
   - dict 对象没有类似的方法。

3. **初始化：**
   - Counter 对象可以接受可迭代对象并自动统计各元素出现的次数。
   - dict 对象需要手动添加键值对。

4. **值的类型：**
   - Counter 对象的值（即计数）可以是任意整数。
   - dict 对象的值可以是任意对象。

5. **操作：**
   - Counter 对象的一些操作（如加法、减法）会自动合并相同键的计数。
   - dict 对象不会对值进行特殊处理。

综上所述，Counter 对象是专门用于计数目的的字典子类，提供了方便的方法来处理元素计数任务。



#### 02 Python库collections

[【万字长文详解】Python库collections，让你击败99%的Pythoner - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/343747724)

**1、模块作用**

**官方说法：**collections模块实现了特定目标的容器，以提供Python标准内建容器dict ,list , set , 和tuple的替代选择。

**通俗说法：**Python内置的数据类型和方法，collections模块在这些内置类型的基础提供了额外的高性能数据类型，比如基础的字典是不支持顺序的，collections模块的OrderedDict类构建的字典可以支持顺序，collections模块的这些扩展的类用处非常大，熟练掌握该模块，可以大大简化Python代码，提高Python代码逼格和效率，**高手入门必备。**



这个模块实现了特定目标的容器，以提供Python标准内建容器dict , list , set , 和tuple 的替代选择。

| namedtuple() | 创建命名元组子类的工厂函数，生成可以使用名字来访问元素内容的tuple子类 |
| ------------ | ------------------------------------------------------------ |
| deque        | 类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop) |
| ChainMap     | 类似字典(dict)的容器类，将多个映射集合到一个视图里面         |
| Counter      | 字典的子类，提供了可哈希对象的计数功能                       |
| OrderedDict  | 字典的子类，保存了他们被添加的顺序，有序字典                 |
| defaultdict  | 字典的子类，提供了一个工厂函数，为字典查询提供一个默认值     |
| UserDict     | 封装了字典对象，简化了字典子类化                             |
| UserList     | 封装了列表对象，简化了列表子类化                             |
| UserString   | 封装了字符串对象，简化了字符串子类化（中文版翻译有误）       |



#### 03 python基础运算符

当然，以下是以 Markdown 笔记形式回答 Python 基础运算符：

---

#### 04 Python 基础运算符

> [python运算符——身份运算符详解【21年10月更新】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/422329947#SnippetTab)

**算术运算符**

- `+`：加法运算符，用于两个数相加。
- `-`：减法运算符，用于第一个数减去第二个数。
- `*`：乘法运算符，用于两个数相乘。
- `/`：除法运算符，用于第一个数除以第二个数。
- `//`：地板除运算符，结果向下取整。
- `%`：取模运算符，返回除法的余数。
- `**`：幂运算符，用于求一个数的指数幂。

**比较运算符**

- `==`：等于运算符，检查两个数是否相等。
- `!=`：不等于运算符，检查两个数是否不相等。
- `>`：大于运算符，检查第一个数是否大于第二个数。
- `<`：小于运算符，检查第一个数是否小于第二个数。
- `>=`：大于等于运算符，检查第一个数是否大于或等于第二个数。
- `<=`：小于等于运算符，检查第一个数是否小于或等于第二个数。

**逻辑运算符**

- `and`：与运算符，如果两个条件都为真，则返回 True。
- `or`：或运算符，如果至少一个条件为真，则返回 True。
- `not`：非运算符，用于反转条件的结果。

**位运算符**

- `&`：按位与运算符。
- `|`：按位或运算符。
- `^`：按位异或运算符。
- `~`：按位取反运算符。
- `<<`：左移位运算符。
- `>>`：右移位运算符。

**赋值运算符**

- `=`：简单的赋值运算符。
- `+=`、`-=`、`*=`、`/=`、`%=`、`//=`、`**=`：加、减、乘、除、取模、地板除、幂赋值运算符。

**成员运算符**

- `in`：如果在序列中找到指定的值，则返回 True。
- `not in`：如果在序列中没有找到指定的值，则返回 True。

**身份运算符**

- `is`：如果两个变量引用同一个对象，则返回 True。
- `is not`：如果两个变量引用的不是同一个对象，则返回 True。

**其他运算符**

- `:`：用于切片操作。
- `,`：用于分隔元素、参数或键值对。
- `()`：用于表示元组、函数调用、表达式分组等。





#### 05 Python集合和字典的异同

**相同点：**

1. **无序性：** 集合和字典都是无序的数据结构，其中元素（或键）的存储顺序不受控制。
2. **可变性：** 集合和字典都是可变的，可以通过添加、删除和更新元素（或键值对）来改变它们的内容。
3. **唯一性：** 集合中不允许有重复的元素，字典中的键也必须是唯一的。

**不同点：**

1. **元素类型：** 集合中存储的是单个的元素，而字典中存储的是键值对。
2. **访问方式：** 集合中的元素可以通过迭代访问，但是不能通过索引来访问；字典中的元素可以通过键来访问，因为字典是基于键的哈希表实现的。
3. **存储方式：** 集合使用大括号 `{}` 来表示，其中的元素之间用逗号 `,` 分隔；字典使用大括号 `{}` 来表示，其中的键值对之间用冒号 `:` 分隔，键值对之间用逗号 `,` 分隔。
4. **迭代方式：** 集合可以直接进行迭代，而字典默认情况下会对键进行迭代，可以使用 `.values()` 方法迭代字典中的值，`.items()` 方法迭代字典中的键值对。
5. **内存占用：** 字典比集合更占内存，因为字典需要存储键值对，而集合只需要存储元素。

综上所述，集合和字典都是非常有用的数据结构，但它们在用法和特性上有一些区别，选择使用哪种取决于你的需求和数据结构的特性。

#### 06 python 字典遍历

1. **遍历键（keys）**：
```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
for key in my_dict:
    print(key)
```

2. **遍历值（values）**：
```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
for value in my_dict.values():
    print(value)
```

3. **遍历键值对（items）**：
```python
my_dict = {'a': 1, 'b': 2, 'c': 3}
for key, value in my_dict.items():
    print(key, value)
```

这些方法可以根据你的需求选择适合的遍历方式。



#### 07 python 列表排序

在Python中，可以使用内置的`sorted()`函数或列表对象的`sort()`方法对列表进行排序。

1. 使用`sorted()`函数：
```python
my_list = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
sorted_list = sorted(my_list)  # 返回一个新的已排序列表
print(sorted_list)
```

2. 使用列表对象的`sort()`方法：
```python
my_list = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
my_list.sort()  # 原地排序，不返回新列表
print(my_list)
```

默认情况下，这两种方法都会按升序对列表进行排序。如果需要按降序排序，则可以传递`reverse=True`参数：

```python
my_list = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

# 使用 sorted() 函数
sorted_list_desc = sorted(my_list, reverse=True)
print(sorted_list_desc)

# 使用 sort() 方法
my_list.sort(reverse=True)
print(my_list)
```

如果你需要按照自定义规则进行排序，可以传递一个`key`函数，该函数接受列表的元素作为输入，并返回用于排序的关键字。例如，按照列表中每个元素的绝对值进行排序：

```python
my_list = [-3, 1, -4, 1, 5, -9, 2, 6, 5, 3, 5]

# 使用 sorted() 函数
sorted_list_abs = sorted(my_list, key=abs)
print(sorted_list_abs)

# 使用 sort() 方法
my_list.sort(key=abs)
print(my_list)

```

使用函数排序

```
node_list.sort(key=lambda x: x.val)
```



#### 08 python 不可哈希对象

> [Python 的 unhashable type 错误分析及解决 (icejoywoo.github.io)](https://icejoywoo.github.io/2019/03/16/python-unhashable-type-error.html)
>
> [谈谈__eq__和__hash__ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37643853)

在Python中，unhashable type指的是那些不能被用作字典的键或者集合中的元素的数据类型。这是因为字典的键和集合的元素需要保持不变（immutable），以便它们可以被哈希化，从而快速地在数据结构中查找。
以下是一些常见的unhashable types：

1. 列表（list）：列表是可变的，可以增加、删除或更改其中的元素，因此它们不能被哈希化。
2. 集合（set）：集合也是可变的，可以添加或删除元素，因此不能作为字典的键。
3. 字典（dict）：字典本身是可变的，可以更改键值对，所以不能作为另一个字典的键。
4. 文件对象：文件对象是可变的，因为它们可以进行读写操作，所以不能被哈希化。
5. 线程对象：线程对象是可变的，因为它们可以改变状态，所以不能作为字典的键。
6. 多数用户定义的类实例：默认情况下，用户定义的类实例也是不可哈希的，因为它们是可变的。但是，可以通过定义类的 `__hash__` 方法来使类的实例变得可哈希。
需要注意的是，所有不可变的数据类型，如整数（int）、浮点数（float）、字符串（str）、元组（tuple）等，都是hashable的，可以作为字典的键或集合的元素。
在编写程序时，如果需要将可变类型作为字典的键，可以考虑将其转换为不可变类型，如将列表转换为元组，或者定义一个不可变的数据结构来满足需求。



在Python中，通常情况下，不可哈希类型（unhashable type）指的是不能作为字典（dict）的键或集合（set）的成员的类型。Python中的可哈希类型必须满足一定的条件，主要是不可变性。以下是一些常见的不可哈希类型：

1. 列表（list）：列表是可变的，因此不能作为字典的键或集合的成员。

```python
my_dict = {[1, 2]: "value"}  # 会引发 TypeError
my_set = { [1, 2, 3] }       # 会引发 TypeError
```

2. 集合（set）：集合本身是可变的，因此不能作为字典的键或另一个集合的成员。

```python
my_dict = {{1, 2, 3}: "value"}  # 会引发 TypeError
my_set = { {1, 2, 3} }         # 会引发 TypeError
```

3. 字典（dict）：字典是可变的，因此不能作为字典的键。

```python
my_dict = { {"key": "value"}: "value"}  # 会引发 TypeError
```

4. 具有可变元素的元组（tuple）：如果元组中包含可变对象（如列表），则该元组也是不可哈希的。

```python
my_dict = { (1, [2, 3]): "value"}  # 会引发 TypeError
```

5. 自定义的不可变类型但未正确实现`__hash__()`方法的类：如果自定义的不可变类型没有正确实现`__hash__()`方法，它也会被视为不可哈希。

```python
class Unhashable:
    def __init__(self, value):
        self.value = value

my_set = { Unhashable(10) }  # 会引发 TypeError
```

以上是一些常见的不可哈希类型示例。在实际编程中，要注意使用可哈希类型作为字典的键或集合的成员，以避免引发 TypeError。

[为什么堆化 heapify() 只用 O(n) 就做到了？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/266665145)

为什么堆化 heapify() 只用 O(n) 就做到了？

https://blog.csdn.net/dream_follower/article/details/105202811

图解大根堆的堆排序





大根堆和小根堆的区别仅仅在于 大根堆的头是最大的，小根堆的头是最小的，对于其每个子树都是如此

+ 上浮：适用于插入，原本是一个大根堆，插入最后一个元素，然后不停和父节点进行对比，比父节点大，则下沉

+ 下沉：适用于堆化，自底向上，从倒数第二层节点开始，将每个节点调整为大根堆或者小根堆，然后逐级往上，直到最后根节点下沉

  > 下沉（大根堆）的步骤是，如果比左右子节点大，则跳过，如果比某个节点小，那么调换位置，从该节点处继续往下下沉，因为是自底向上的下沉，因此堆化正确



![img](assets/v2-676145506a3b5bb349e7f3d730974967_r.jpg)

复杂度分析

O(n) + O(nlogk)